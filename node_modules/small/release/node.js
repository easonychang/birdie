"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ts = require("typescript");
var Binding = (function () {
    function Binding(declarations) {
        this.declarations = undefined;
        this.references = [];
        this.declarations = declarations;
    }
    return Binding;
}());
exports.Binding = Binding;
var Node = (function () {
    function Node(ast) {
        this.binding = undefined;
        this.ast = ast;
    }
    return Node;
}());
exports.Node = Node;
var ExportNode = (function (_super) {
    __extends(ExportNode, _super);
    function ExportNode() {
        var _this = _super.apply(this, arguments) || this;
        /**
         * Assigned value when this node is an assignment, like `exports.foo = [..]` or `module.exports = [..]`
         */
        _this.assignmentValue = undefined;
        /**
         * True when the assignment uses a compound operator, like `+=` (instead of `=`)
         */
        _this.compoundAssignment = undefined;
        /**
         * True when the export uses `module.exports` instead of `exports`
         */
        _this.isModuleExports = false;
        _this.name = undefined;
        return _this;
    }
    ExportNode.tryParse = function (checker, ast, insideFunction, disallowDots) {
        if (ast === undefined)
            return undefined;
        if (ast.kind === ts.SyntaxKind.Identifier) {
            if (ast.text !== 'exports')
                return undefined;
            if (checker.getSymbolAtLocation(ast) !== undefined)
                return undefined;
            return new ExportNode(ast);
        }
        else if (ast.kind === ts.SyntaxKind.ThisKeyword) {
            if (insideFunction)
                return undefined;
            return new ExportNode(ast);
        }
        else if (ast.kind === ts.SyntaxKind.PropertyAccessExpression) {
            var expression = ast.expression;
            var name_1 = ast.name.text;
            // Check for `module.exports`
            if (expression.kind === ts.SyntaxKind.Identifier && expression.text === 'module' && name_1 === 'exports') {
                var symbol = checker.getSymbolAtLocation(expression);
                if (symbol === undefined || symbol.name === 'export=') {
                    var node = new ExportNode(ast);
                    node.isModuleExports = true;
                    return node;
                }
            }
            // We wont parse things like `exports.foo.bar`.
            if (disallowDots)
                return undefined;
            var parent_1 = ExportNode.tryParse(checker, expression, insideFunction, true);
            if (parent_1) {
                parent_1.ast = ast;
                parent_1.name = name_1;
                return parent_1;
            }
        }
        else if (ast.kind === ts.SyntaxKind.BinaryExpression) {
            var compound = false;
            switch (ast.operatorToken.kind) {
                case ts.SyntaxKind.PlusEqualsToken:
                case ts.SyntaxKind.MinusEqualsToken:
                case ts.SyntaxKind.AsteriskEqualsToken:
                case ts.SyntaxKind.SlashEqualsToken:
                case ts.SyntaxKind.AmpersandEqualsToken:
                case ts.SyntaxKind.BarEqualsToken:
                case ts.SyntaxKind.CaretEqualsToken:
                case ts.SyntaxKind.LessThanLessThanEqualsToken:
                case ts.SyntaxKind.PercentEqualsToken:
                case ts.SyntaxKind.GreaterThanGreaterThanEqualsToken:
                case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
                    compound = true;
                /* fall through */
                case ts.SyntaxKind.EqualsToken:
                    var parent_2 = ExportNode.tryParse(checker, ast.left, insideFunction, true);
                    if (parent_2) {
                        parent_2.assignmentValue = ast.right;
                        parent_2.compoundAssignment = compound;
                        return parent_2;
                    }
                    break;
            }
        }
        return undefined;
    };
    ExportNode.prototype.emit = function (exportsVariable, moduleExportsVariable) {
        var code;
        if (this.isModuleExports) {
            code = moduleExportsVariable;
        }
        else {
            code = exportsVariable;
        }
        if (this.name) {
            code += '.' + this.name;
        }
        return code;
    };
    return ExportNode;
}(Node));
exports.ExportNode = ExportNode;
var ImportNode = (function (_super) {
    __extends(ImportNode, _super);
    function ImportNode() {
        var _this = _super.apply(this, arguments) || this;
        _this.references = [];
        /**
         * Symbol of the variable if the import is assigned to a variable.
         * For instance, `var foo = require('bar')`
         */
        _this.symbol = undefined;
        /**
         * Path used in the `require` call.
         */
        _this.relativePath = undefined;
        _this.targetFile = undefined;
        _this.targetGlobalModule = undefined;
        /**
         * Path of property access expressions after the `require` call.
         * Example: The `dotArray` of `var a = require('b').c.d;` is `['c', 'd']`
         */
        _this.dotArray = [];
        return _this;
    }
    ImportNode.tryParse = function (checker, ast) {
        if (ast === undefined)
            return undefined;
        if (ast.kind === ts.SyntaxKind.CallExpression) {
            // require('foo');
            if (ast.arguments.length !== 1)
                return undefined;
            var expression = ast.expression;
            if (expression.kind !== ts.SyntaxKind.Identifier)
                return undefined;
            if (expression.text !== 'require')
                return undefined;
            if (checker.getSymbolAtLocation(expression) !== undefined)
                return undefined;
            var argument = ast.arguments[0];
            if (argument.kind !== ts.SyntaxKind.StringLiteral)
                return undefined;
            var path = argument.text;
            var importNode = new ImportNode(ast);
            importNode.relativePath = path;
            return importNode;
        }
        else if (ast.kind === ts.SyntaxKind.PropertyAccessExpression) {
            // require('foo').bar
            var parent_3 = ImportNode.tryParse(checker, ast.expression);
            if (parent_3) {
                parent_3.ast = ast;
                parent_3.dotArray.push(ast.name.text);
                return parent_3;
            }
        }
        else if (ast.kind === ts.SyntaxKind.VariableDeclaration) {
            // Possible inputs:
            // var foo = require('foo')
            // var bar = require('foo').bar
            var variable = ast.name;
            if (variable.kind !== ts.SyntaxKind.Identifier)
                return undefined;
            var parent_4 = ImportNode.tryParse(checker, ast.initializer);
            if (parent_4) {
                parent_4.ast = ast;
                parent_4.symbol = checker.getSymbolAtLocation(ast.name);
                return parent_4;
            }
        }
        return undefined;
    };
    ImportNode.prototype.getTargetVariable = function () {
        if (this.targetFile) {
            return this.targetFile.varName;
        }
        else {
            return this.targetGlobalModule._varName;
        }
    };
    ImportNode.prototype.emit = function () {
        var variable = this.getTargetVariable();
        var circular = this.targetFile && this.targetFile.hasCircularDependencies;
        if (circular) {
            variable += '()';
        }
        var property = '';
        for (var _i = 0, _a = this.dotArray; _i < _a.length; _i++) {
            var item = _a[_i];
            property += '.' + item;
        }
        if (this.symbol) {
            if (this.dotArray.length > 0) {
                // Import looks like `var a = require('b').c.d`
                return this.symbol.name + ' = ' + variable + property;
            }
            else if (circular) {
                return this.symbol.name + ' = ' + variable;
            }
            else {
                // Import looks like `var a = require('b')`, and it's not a circular dependency.
                // We will rename `a` to the variable name of the target file.
                return '';
            }
        }
        else {
            return variable + property;
        }
    };
    return ImportNode;
}(Node));
exports.ImportNode = ImportNode;
var ImportReference = (function (_super) {
    __extends(ImportReference, _super);
    function ImportReference(ast, importNode, dotArray) {
        if (dotArray === void 0) { dotArray = []; }
        var _this = _super.call(this, ast) || this;
        _this.importNode = importNode;
        _this.dotArray = dotArray;
        return _this;
    }
    ImportReference.tryParse = function (checker, importNodes, ast) {
        if (ast === undefined)
            return undefined;
        if (ast.kind === ts.SyntaxKind.Identifier) {
            var symbol = checker.getSymbolAtLocation(ast);
            if (symbol === undefined)
                return undefined;
            for (var _i = 0, importNodes_1 = importNodes; _i < importNodes_1.length; _i++) {
                var importNode = importNodes_1[_i];
                if (importNode.symbol === symbol) {
                    if (ast.parent === importNode.ast) {
                        // We found the identifier in
                        // `var a = require('b')`
                        break;
                    }
                    return new ImportReference(ast, importNode);
                }
            }
        }
        else if (ast.kind === ts.SyntaxKind.PropertyAccessExpression) {
            var parent_5 = ImportReference.tryParse(checker, importNodes, ast.expression);
            if (parent_5) {
                parent_5.ast = ast;
                parent_5.dotArray.push(ast.name.text);
                return parent_5;
            }
        }
        return undefined;
    };
    ImportReference.prototype.emit = function () {
        var circular = this.importNode.targetFile && this.importNode.targetFile.hasCircularDependencies;
        if (this.importNode.symbol && this.importNode.dotArray.length === 0 && !circular) {
            // Rename the variable
            var variable = this.importNode.getTargetVariable();
            var property = '';
            for (var _i = 0, _a = this.dotArray; _i < _a.length; _i++) {
                var item = _a[_i];
                property += '.' + item;
            }
            return variable + property;
        }
    };
    return ImportReference;
}(Node));
exports.ImportReference = ImportReference;
