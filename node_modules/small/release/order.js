"use strict";
/// <reference path="../definitions/ref.d.ts" />
var graphlib_1 = require("graphlib");
function generateOrder(proj) {
    var inputGraph = new graphlib_1.Graph({ directed: true });
    for (var _i = 0, _a = proj.files; _i < _a.length; _i++) {
        var file_1 = _a[_i];
        inputGraph.setNode(file_1.filename, {
            file: file_1,
            groupName: undefined
        });
    }
    for (var _b = 0, _c = proj.files; _b < _c.length; _b++) {
        var file_2 = _c[_b];
        for (var _d = 0, _e = file_2.dependencies; _d < _e.length; _d++) {
            var dependency = _e[_d];
            inputGraph.setEdge(file_2.filename, dependency.filename);
        }
    }
    var acyclicGraph = new graphlib_1.Graph({ directed: true });
    for (var _f = 0, _g = graphlib_1.alg.tarjan(inputGraph); _f < _g.length; _f++) {
        var group = _g[_f];
        acyclicGraph.setNode(group[0], {
            filenames: group
        });
        for (var _h = 0, group_1 = group; _h < group_1.length; _h++) {
            var member = group_1[_h];
            inputGraph.node(member).groupName = group[0];
        }
    }
    for (var _j = 0, _k = inputGraph.nodes(); _j < _k.length; _j++) {
        var filename = _k[_j];
        var groupName = inputGraph.node(filename).groupName;
        for (var _l = 0, _m = inputGraph.inEdges(filename); _l < _m.length; _l++) {
            var edge = _m[_l];
            var otherGroup = inputGraph.node(edge.w).groupName;
            if (groupName !== otherGroup)
                acyclicGraph.setEdge(groupName, otherGroup);
        }
    }
    var order = graphlib_1.alg.topsort(acyclicGraph);
    var index = 0;
    for (var _o = 0, order_1 = order; _o < order_1.length; _o++) {
        var groupName = order_1[_o];
        var group = acyclicGraph.node(groupName);
        var component = [];
        var cyclic = group.filenames.length !== 1;
        for (var _p = 0, _q = group.filenames; _p < _q.length; _p++) {
            var filename = _q[_p];
            var file_3 = inputGraph.node(filename).file;
            if (cyclic) {
                file_3.hasCircularDependencies = true;
                file_3.connectedComponent = component;
                component.push(file_3);
            }
            else {
                file_3.hasCircularDependencies = false;
            }
            file_3.orderIndex = index++;
            proj.orderFiles.push(file_3);
        }
    }
}
exports.generateOrder = generateOrder;
