/// <reference path="../definitions/ref.d.ts" />
"use strict";
var ts = require("typescript");
var node_1 = require("./node");
var defaultFileName = 'file.ts';
var Parser = (function () {
    function Parser() {
    }
    Parser.prototype.parse = function (file) {
        var ast = ts.createSourceFile(defaultFileName, file.source, ts.ScriptTarget.Latest, true);
        file.ast = ast;
        var host = {
            getSourceFile: function (fileName, languageVersion) {
                if (fileName === defaultFileName)
                    return ast;
            },
            getDefaultLibFileName: function (options) { return ''; },
            writeFile: function () { },
            getCurrentDirectory: function () { return ''; },
            getCanonicalFileName: function (fileName) { return fileName; },
            useCaseSensitiveFileNames: function () { return true; },
            getDirectories: function () { return []; },
            getNewLine: function () { return '\n\r'; },
            fileExists: function (fileName) { return fileName === defaultFileName; },
            readFile: function (fileName) { return fileName === defaultFileName ? file.source : undefined; }
        };
        var program = ts.createProgram([defaultFileName], {
            noResolve: true,
            noEmit: true,
            target: ts.ScriptTarget.Latest,
            module: ts.ModuleKind.None,
            noLib: true
        }, host);
        var typeChecker = program.getTypeChecker();
        var walker = new Walker();
        var importNodes = [];
        var exportNodes = [];
        // Find import & export nodes.
        walker.walk(ast, function (child) {
            var importNode = node_1.ImportNode.tryParse(typeChecker, child);
            if (importNode) {
                importNodes.push(importNode);
                // Don't descend
                return;
            }
            var exportNode = node_1.ExportNode.tryParse(typeChecker, child, walker.isInFunction);
            if (exportNode) {
                exportNodes.push(exportNode);
                if (exportNode.assignmentValue)
                    walker.visit(exportNode.assignmentValue);
                return;
            }
            walker.descend();
        });
        // Find import references
        walker.walk(ast, function (child) {
            var reference = node_1.ImportReference.tryParse(typeChecker, importNodes, child);
            if (reference) {
                reference.importNode.references.push(reference);
            }
            else {
                walker.descend();
            }
        });
        file.importNodes = importNodes;
        file.exportNodes = exportNodes;
    };
    return Parser;
}());
exports.Parser = Parser;
var Walker = (function () {
    function Walker() {
        this.node = undefined;
        this.isConditional = false;
        this.isInFunction = false;
    }
    Walker.prototype.walk = function (node, callback) {
        this.callback = callback;
        this.visit(node);
    };
    Walker.prototype.visit = function (node) {
        if (!node)
            return;
        var saveNode = this.node;
        var saveIsConditional = this.isConditional;
        var saveIsInFunction = this.isInFunction;
        this.node = node;
        switch (node.kind) {
            case ts.SyntaxKind.FunctionDeclaration:
            case ts.SyntaxKind.FunctionExpression:
            case ts.SyntaxKind.ClassDeclaration:
            case ts.SyntaxKind.ClassExpression:
                this.isConditional = true;
                this.isInFunction = true;
                break;
        }
        if (!this.isConditional && node.parent) {
            switch (node.parent.kind) {
                case ts.SyntaxKind.IfStatement:
                    if (node === node.parent.thenStatement || node === node.parent.elseStatement) {
                        this.isConditional = true;
                    }
                    break;
                case ts.SyntaxKind.ForStatement:
                case ts.SyntaxKind.ForOfStatement:
                case ts.SyntaxKind.ForInStatement:
                case ts.SyntaxKind.WhileStatement:
                case ts.SyntaxKind.DoStatement:
                    if (node.parent.statement === node) {
                        this.isConditional = true;
                    }
                    break;
                case ts.SyntaxKind.BinaryExpression:
                    var expression = node.parent;
                    if (expression.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken
                        || expression.operatorToken.kind === ts.SyntaxKind.BarBarToken) {
                        if (expression.right === node) {
                            this.isConditional = true;
                        }
                    }
                    break;
            }
        }
        this.callback(node);
        this.node = saveNode;
        this.isConditional = saveIsConditional;
        this.isInFunction = saveIsInFunction;
    };
    Walker.prototype.descend = function (node) {
        var _this = this;
        if (node === void 0) { node = this.node; }
        ts.forEachChild(node, function (child) { return _this.visit(child); });
    };
    return Walker;
}());
