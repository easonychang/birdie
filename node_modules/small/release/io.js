/// <reference path="../definitions/ref.d.ts" />
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Vinyl = require("vinyl");
var sourceMap = require("source-map");
var Promise = require("bluebird");
var fs = require("fs");
var stream = require("stream");
var events = require("events");
var ReadOperation;
(function (ReadOperation) {
    ReadOperation[ReadOperation["FILE_EXISTS"] = 0] = "FILE_EXISTS";
    ReadOperation[ReadOperation["DIRECTORY_EXISTS"] = 1] = "DIRECTORY_EXISTS";
    ReadOperation[ReadOperation["READ_FILE"] = 2] = "READ_FILE";
})(ReadOperation || (ReadOperation = {}));
function normalizePath(path) {
    if (!path)
        return path;
    return path.toLowerCase().replace(/\\/g, '/');
}
exports.normalizePath = normalizePath;
function pathsEqual(a, b) {
    return normalizePath(a) === normalizePath(b);
}
exports.pathsEqual = pathsEqual;
var NodeIO = (function () {
    function NodeIO(cwd) {
        if (cwd === void 0) { cwd = process.cwd(); }
        this.includeSourceMapComment = true;
        this.cwd = cwd;
    }
    NodeIO.prototype.fileExists = function (path) {
        return new Promise(function (resolve, reject) {
            fs.stat(path, function (err, res) {
                if (err)
                    return reject(err);
                if (!res)
                    resolve(false);
                resolve(res.isFile());
            });
        });
    };
    NodeIO.prototype.directoryExists = function (path) {
        return new Promise(function (resolve, reject) {
            fs.stat(path, function (err, res) {
                if (err)
                    return reject(err);
                if (!res)
                    resolve(false);
                resolve(res.isDirectory());
            });
        });
    };
    NodeIO.prototype.readFile = function (path) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            fs.readFile(path, function (err, res) {
                if (err)
                    return reject(err);
                resolve(new Vinyl({
                    path: path,
                    contents: res,
                    cwd: _this.cwd
                }));
            });
        });
    };
    NodeIO.prototype.writeFile = function (file, sourceMap) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            fs.writeFile(file.path, file.contents, function (err) {
                if (err)
                    return reject(err);
                if (sourceMap)
                    resolve(_this.writeFile(sourceMap));
                resolve(true);
            });
        });
    };
    return NodeIO;
}());
exports.NodeIO = NodeIO;
var StreamIO = (function (_super) {
    __extends(StreamIO, _super);
    function StreamIO() {
        var _this = _super.call(this) || this;
        _this.includeSourceMapComment = false;
        _this._files = [];
        _this._queuedReads = [];
        _this.stream = new StreamIO.DuplexStream(function (file) {
            _this._addFile(file);
        }, function () {
            _this._end();
        });
        return _this;
    }
    StreamIO.prototype._findLocalFile = function (path) {
        for (var i = 0; i < this._files.length; ++i) {
            var file = this._files[i];
            if (pathsEqual(file.path, path))
                return file;
        }
        return undefined;
    };
    StreamIO.prototype._addFile = function (file) {
        this._files.push(file);
        this._queuedReads = this._queuedReads.filter(function (read) {
            if (pathsEqual(read.path, file.path)) {
                switch (read.operation) {
                    case ReadOperation.FILE_EXISTS:
                        read.resolve(true);
                        break;
                    case ReadOperation.READ_FILE:
                        read.resolve(file);
                        break;
                }
                return false; // Remove from queue
            }
            var normalizedPath = normalizePath(read.path);
            if (read.operation === ReadOperation.DIRECTORY_EXISTS && normalizePath(file.path).substr(0, normalizedPath.length) === normalizedPath) {
                read.resolve(true);
                return false; // Remove from queue
            }
            return true;
        });
        this.emit('addFile', undefined, file);
    };
    StreamIO.prototype._end = function () {
        this._finished = true;
        this._queuedReads.forEach(function (read) {
            var err = new Error('ENOENT, no such file or directory, ' + read.path);
            err.code = 'ENOENT';
            read.reject(err);
        });
        this._queuedReads = [];
        this.emit('end');
    };
    StreamIO.prototype.fileExists = function (path) {
        var _this = this;
        if (this._findLocalFile(path)) {
            return Promise.resolve(true);
        }
        else if (this._finished) {
            return Promise.resolve(false);
        }
        else {
            return new Promise(function (resolve, reject) {
                _this._queuedReads.push({
                    path: path,
                    operation: ReadOperation.FILE_EXISTS,
                    reject: reject,
                    resolve: resolve
                });
            });
        }
    };
    StreamIO.prototype.directoryExists = function (path) {
        var _this = this;
        var normalizedPath = normalizePath(path);
        if (normalizedPath.substr(normalizedPath.length - 1) !== '/') {
            normalizedPath += '/';
            path += '/';
        }
        for (var i = 0; i < this._files.length; ++i) {
            var file = this._files[i];
            if (normalizePath(file.path.substr(0, path.length)) === normalizedPath) {
                return Promise.resolve(true);
            }
        }
        if (this._finished) {
            return Promise.resolve(false);
        }
        else {
            return new Promise(function (resolve, reject) {
                _this._queuedReads.push({
                    path: normalizedPath,
                    operation: ReadOperation.DIRECTORY_EXISTS,
                    reject: reject,
                    resolve: resolve
                });
            });
        }
    };
    StreamIO.prototype.readFile = function (path) {
        var _this = this;
        var file = this._findLocalFile(path);
        if (file) {
            return Promise.resolve(file);
        }
        else if (this._finished) {
            var err = new Error('ENOENT, no such file or directory, ' + path);
            err.code = 'ENOENT';
            return Promise.reject(err);
        }
        else {
            return new Promise(function (resolve, reject) {
                _this._queuedReads.push({
                    path: path,
                    operation: ReadOperation.READ_FILE,
                    reject: reject,
                    resolve: resolve
                });
            });
        }
    };
    StreamIO.prototype.writeFile = function (file, sourceMapFile) {
        if (sourceMapFile) {
            var generator = sourceMap.SourceMapGenerator.fromSourceMap(new sourceMap.SourceMapConsumer(JSON.parse(sourceMapFile.contents.toString())));
            for (var _i = 0, _a = this._files; _i < _a.length; _i++) {
                var source = _a[_i];
                if (source.sourceMap) {
                    generator.applySourceMap(new sourceMap.SourceMapConsumer(source.sourceMap));
                }
            }
            file.sourceMap = JSON.parse(generator.toString());
        }
        this.stream.push(file);
        return Promise.resolve(true);
    };
    return StreamIO;
}(events.EventEmitter));
exports.StreamIO = StreamIO;
(function (StreamIO) {
    var DuplexStream = (function (_super) {
        __extends(DuplexStream, _super);
        function DuplexStream(onFile, onEnd) {
            var _this = _super.call(this, { objectMode: true }) || this;
            _this._onFile = onFile;
            _this._onEnd = onEnd;
            return _this;
        }
        DuplexStream.prototype._write = function (file, encoding, cb) {
            if (cb === void 0) { cb = function (err) { }; }
            if (!file)
                return cb();
            if (file.isNull()) {
                cb();
                return;
            }
            if (file.isStream()) {
                return new Error('Stream not supported');
            }
            this._onFile(file);
            cb();
        };
        DuplexStream.prototype._read = function () {
        };
        DuplexStream.prototype.end = function (chunk, encoding, callback) {
            this._write(chunk, encoding, callback);
            this._onEnd();
        };
        return DuplexStream;
    }(stream.Duplex));
    StreamIO.DuplexStream = DuplexStream;
})(StreamIO = exports.StreamIO || (exports.StreamIO = {}));
var HybridIO = (function () {
    function HybridIO(mainIO, altIO, altPaths, altReadOnly) {
        if (altReadOnly === void 0) { altReadOnly = false; }
        this.mainIO = mainIO;
        this.altIO = altIO;
        this.altPaths = altPaths;
        this.altReadOnly = altReadOnly;
        this.includeSourceMapComment = mainIO.includeSourceMapComment;
    }
    HybridIO.prototype.needsAltIO = function (path) {
        path = normalizePath(path);
        return this.altPaths.some(function (altPath) {
            altPath = normalizePath(altPath);
            return path.substr(0, altPath.length) === altPath;
        });
    };
    HybridIO.prototype.fileExists = function (path) {
        if (this.needsAltIO(path)) {
            return this.altIO.fileExists(path);
        }
        else {
            return this.mainIO.fileExists(path);
        }
    };
    HybridIO.prototype.directoryExists = function (path) {
        if (this.needsAltIO(path)) {
            return this.altIO.directoryExists(path);
        }
        else {
            return this.mainIO.directoryExists(path);
        }
    };
    HybridIO.prototype.readFile = function (path) {
        if (this.needsAltIO(path)) {
            return this.altIO.readFile(path);
        }
        else {
            return this.mainIO.readFile(path);
        }
    };
    HybridIO.prototype.writeFile = function (file, sourceMapFile) {
        if (this.needsAltIO(file.path) && !this.altReadOnly) {
            return this.altIO.writeFile(file, sourceMapFile);
        }
        else {
            return this.mainIO.writeFile(file, sourceMapFile);
        }
    };
    return HybridIO;
}());
exports.HybridIO = HybridIO;
