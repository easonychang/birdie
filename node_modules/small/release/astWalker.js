/// <reference path="../definitions/ref.d.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ts = require('typescript');
var exportNode = require('./exportNode');
var importNode = require('./importNode');
function isDefined(f, identifier) {
    return f.types.getSymbolAtLocation(identifier) !== undefined;
}
function matchExportsAlias(f, node, isTopLevel) {
    // this
    if (node.kind === 93 /* ThisKeyword */ && isTopLevel) {
        return {
            style: exportNode.Style.This,
            dotArray: [],
            exportAST: node,
            ast: node
        };
    }
    // exports
    if (node.kind === 65 /* Identifier */) {
        var nodeVar = node;
        if (nodeVar.text === 'exports' && !isDefined(f, nodeVar)) {
            return {
                style: exportNode.Style.Exports,
                dotArray: [],
                exportAST: nodeVar,
                ast: nodeVar
            };
        }
    }
    if (node.kind === 155 /* PropertyAccessExpression */) {
        var nodeAccess = node;
        // module.exports
        if (nodeAccess.expression.kind === 65 /* Identifier */ && nodeAccess.name.text === 'exports') {
            var expressionVal = nodeAccess.expression;
            if (expressionVal.text === 'module' && !isDefined(f, expressionVal)) {
                return {
                    style: exportNode.Style.ModuleExports,
                    dotArray: [],
                    exportAST: nodeAccess,
                    ast: nodeAccess
                };
            }
        }
        // [some exports style].[property]
        var exportAlias = matchExportsAlias(f, nodeAccess.name, isTopLevel);
        if (exportAlias) {
            return {
                style: exportAlias.style,
                dotArray: exportAlias.dotArray.concat([nodeAccess.name.text]),
                exportAST: exportAlias.exportAST,
                ast: nodeAccess
            };
        }
    }
}
exports.matchExportsAlias = matchExportsAlias;
var Walker = (function () {
    function Walker() {
        this.node = undefined;
        this.scope = undefined;
        this.isConditional = false;
    }
    Walker.prototype.walk = function (node) {
        var saveNode = this.node;
        var saveScope = this.scope;
        var saveIsConditional = this.isConditional;
        this.node = node;
        switch (node.kind) {
            case 200 /* FunctionDeclaration */:
            case 162 /* FunctionExpression */:
            case 201 /* ClassDeclaration */:
            case 174 /* ClassExpression */:
                this.isConditional = true;
            /* fall through */
            case 227 /* SourceFile */:
                this.scope = node;
                break;
        }
        if (!this.isConditional && node.parent) {
            switch (node.parent.kind) {
                case 183 /* IfStatement */:
                    if (node === node.parent.thenStatement || node === node.parent.elseStatement) {
                        this.isConditional = true;
                    }
                    break;
                case 186 /* ForStatement */:
                case 188 /* ForOfStatement */:
                case 187 /* ForInStatement */:
                case 185 /* WhileStatement */:
                case 184 /* DoStatement */:
                    if (node.parent.statement === node) {
                        this.isConditional = true;
                    }
                    break;
                case 169 /* BinaryExpression */:
                    var expression = node.parent;
                    if (expression.operatorToken.kind === 48 /* AmpersandAmpersandToken */
                        || expression.operatorToken.kind === 49 /* BarBarToken */) {
                        if (expression.right === node) {
                            this.isConditional = true;
                        }
                    }
                    break;
            }
        }
        this.visit(node);
        this.node = saveNode;
        this.scope = saveScope;
        this.isConditional = saveIsConditional;
    };
    Walker.prototype.descent = function () {
        var _this = this;
        ts.forEachChild(this.node, function (node) { return _this.walk(node); });
    };
    Walker.prototype.visit = function (node) {
    };
    return Walker;
})();
var ParseWalker = (function (_super) {
    __extends(ParseWalker, _super);
    function ParseWalker() {
        _super.apply(this, arguments);
        this.importTopLevelIndex = 0;
        this.exportTopLevelIndex = 0;
    }
    ParseWalker.prototype.visit = function (node) {
        // imports
        if (node.kind === 157 /* CallExpression */) {
            var nodeCall = node;
            if (nodeCall.expression.kind === 65 /* Identifier */ && nodeCall.arguments.length === 1) {
                var funcVar = nodeCall.expression;
                if (funcVar.text === 'require' && !isDefined(this.file, funcVar)) {
                    var arg = nodeCall.arguments[0];
                    if (arg.kind !== 8 /* StringLiteral */) {
                        throw new Error('Expressions other than string literals in require calls are not allowed.');
                    }
                    var imp;
                    if (node.parent.kind === 198 /* VariableDeclaration */
                        && node.parent.name.kind === 65 /* Identifier */) {
                        // TODO: imports with properties, like var func require('name').someObj.someFunc;
                        var parentVar = node.parent;
                        var impSimple = new importNode.SimpleImport();
                        impSimple.ast = parentVar;
                        impSimple.importAst = nodeCall;
                        impSimple.dotArray = [];
                        impSimple.symbol = this.file.types.getSymbolAtLocation(parentVar.name);
                        impSimple.safe = true;
                        imp = impSimple;
                    }
                    else {
                        imp = new importNode.Import();
                        imp.ast = nodeCall;
                        imp.importAst = nodeCall;
                        imp.safe = false;
                    }
                    imp.conditional = this.isConditional;
                    imp.safe = imp.safe && !imp.conditional;
                    imp.topLevel = !this.isConditional;
                    if (imp.topLevel) {
                        imp.topLevelIndex = this.importTopLevelIndex++;
                    }
                    imp.relativePath = arg.text;
                    this.file.importNodes.push(imp);
                }
            }
        }
        // exports
        var match = matchExportsAlias(this.file, node, !this.isConditional);
        if (match) {
            if (node.parent.kind === 169 /* BinaryExpression */ && node.parent.operatorToken.kind === 53 /* EqualsToken */) {
                var parentAssign = node.parent;
                if (match.dotArray.length === 0) {
                    if (match.style !== exportNode.Style.ModuleExports) {
                        throw new Error('Use "module.exports = " for export assignments instead of "exports = " or "this = "');
                    }
                    var expF = new exportNode.FullExport();
                    expF.style = match.style;
                    expF.ast = parentAssign;
                    expF.astLeft = match.ast;
                    expF.exportAst = match.exportAST;
                    expF.astRight = parentAssign.right;
                    expF.symbolRight = (expF.astRight.kind === 65 /* Identifier */) ? this.file.types.getSymbolAtLocation(expF.astRight) : undefined;
                    expF.safe = !this.isConditional;
                    this.handleExportTopLevel(expF);
                    this.file.exportNodes.push(expF);
                    return true;
                }
                else {
                    var expS = new exportNode.SingleExport();
                    expS.style = match.style;
                    expS.ast = parentAssign;
                    expS.astLeft = match.ast;
                    expS.exportAst = match.exportAST;
                    expS.astRight = parentAssign.right;
                    expS.symbolRight = (expS.astRight.kind === 65 /* Identifier */) ? this.file.types.getSymbolAtLocation(expS.astRight) : undefined;
                    expS.dotArray = match.dotArray;
                    expS.safe = !this.isConditional;
                    this.handleExportTopLevel(expS);
                    this.file.exportNodes.push(expS);
                    return true;
                }
            }
            else {
                var expU = new exportNode.UnknownExport();
                expU.style = match.style;
                expU.ast = node;
                expU.exportAst = match.exportAST;
                expU.safe = false;
                this.handleExportTopLevel(expU);
                this.file.exportNodes.push(expU);
                return true;
            }
        }
        this.descent();
    };
    ParseWalker.prototype.handleExportTopLevel = function (node) {
        node.topLevel = !this.isConditional;
        if (node.topLevel)
            node.topLevelIndex = this.exportTopLevelIndex++;
    };
    return ParseWalker;
})(Walker);
var SafetyWalker = (function (_super) {
    __extends(SafetyWalker, _super);
    function SafetyWalker() {
        _super.apply(this, arguments);
    }
    SafetyWalker.prototype.visit = function (node) {
        // import
        var symbol;
        if (node.kind === 198 /* VariableDeclaration */) {
            var nodeVarDef = node;
            if (node.initializer) {
                symbol = this.file.types.getSymbolAtLocation(nodeVarDef.name);
            }
        }
        else if (node.kind === 169 /* BinaryExpression */ && node.operatorToken.kind === 53 /* EqualsToken */) {
            var nodeAssign = node;
            if (nodeAssign.left.kind === 65 /* Identifier */) {
                var nodeLeftVar = nodeAssign.left;
                symbol = this.file.types.getSymbolAtLocation(nodeLeftVar);
            }
        }
        var symbolRef;
        if (node.kind === 65 /* Identifier */) {
            symbolRef = this.file.types.getSymbolAtLocation(node);
        }
        if (symbol || symbolRef) {
            for (var i = 0; i < this.file.importNodes.length; ++i) {
                var imp = this.file.importNodes[i];
                if (imp instanceof importNode.SimpleImport) {
                    if (symbolRef && symbolRef === imp.symbol && node.parent !== imp.ast) {
                        imp.references.push(node);
                    }
                    if (!imp.safe || !symbol)
                        continue;
                    if (imp.symbol !== symbol)
                        continue;
                    if (imp.ast === node)
                        continue;
                    imp.safe = false;
                    break;
                }
            }
        }
        this.descent();
    };
    ;
    return SafetyWalker;
})(Walker);
function walkAst(f) {
    var impTopIndex = 0;
    var expTopIndex = 0;
    var walker = new ParseWalker();
    var walkerSafety = new SafetyWalker();
    walker.file = f;
    walkerSafety.file = f;
    walker.walk(f.ast);
    walkerSafety.walk(f.ast);
    // export safety
    var unknownExps = f.getUnknownExportNodes();
    var singleExps = f.getSingleExportNodes();
    var fullExps = f.getFullExportNodes();
    var expSafe;
    if (unknownExps.length !== 0) {
        expSafe = false;
    }
    else if (fullExps.length === 1) {
        if (singleExps.length >= 1) {
            expSafe = false;
        }
        else {
            expSafe = true;
        }
    }
    else if (fullExps.length >= 2) {
        expSafe = false;
    }
    if (expSafe === false || expSafe === true) {
        for (var i = 0; i < f.exportNodes.length; ++i) {
            f.exportNodes[i].safe = expSafe;
        }
    }
    else {
        for (var i = 0; i < singleExps.length; ++i) {
            var exp = singleExps[i];
            if (exp.safe === false)
                continue;
            if (singleExps.filter(function (item) {
                return item.dotArray[0] === exp.dotArray[0];
            }).length === 1) {
                exp.safe = true;
            }
            else {
                exp.safe = false;
            }
        }
    }
}
exports.walkAst = walkAst;
