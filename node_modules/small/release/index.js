/// <reference path="../definitions/ref.d.ts" />
"use strict";
var path = require("path");
var chalk = require("chalk");
var project = require("./project");
var io_1 = require("./io");
exports.Project = project.Project;
exports.io = require("./io");
function compile(startFile, options, callback) {
    var p = new project.Project(startFile, new exports.io.NodeIO(), options);
    p.on('error', function (err) {
        if (callback)
            callback(err);
    });
    p.on('written', function () {
        if (callback)
            callback();
    });
    p.start();
}
exports.compile = compile;
function error(err) {
    var message = err.message;
    var index = message.indexOf('\n');
    if (index === -1) {
        message = chalk.red(message);
    }
    else {
        message = chalk.red(message.substring(0, index)) + message.substring(index);
    }
    console.error(message);
}
exports.error = error;
function gulp(startFileName, options) {
    var _this = this;
    if (startFileName === void 0) { startFileName = 'index.js'; }
    if (options === void 0) { options = {}; }
    var streamIO = new exports.io.StreamIO();
    var stream = streamIO.stream;
    var usedIO;
    var externalResolve = [];
    if (options.includeNode) {
        externalResolve.push(path.join(__dirname, '../node_modules/browser-builtins'));
    }
    if (options.externalResolve) {
        externalResolve = externalResolve.concat(options.externalResolve.map(function (value) { return path.resolve(process.cwd(), value); }));
    }
    if (externalResolve.length > 0) {
        usedIO = new exports.io.HybridIO(streamIO, new exports.io.NodeIO(), externalResolve, true);
    }
    else {
        usedIO = streamIO;
    }
    if (!options.outputFileName) {
        options.outputFileName = {
            standalone: startFileName
        };
    }
    var started = false;
    var gulpCompile = function (startFile) {
        if (started)
            return;
        started = true;
        if (options.outputFileName) {
            if (options.outputFileName.amd) {
                options.outputFileName.amd = path.join(startFile.cwd, options.outputFileName.amd);
            }
            if (options.outputFileName.commonjs) {
                options.outputFileName.commonjs = path.join(startFile.cwd, options.outputFileName.commonjs);
            }
            if (options.outputFileName.standalone) {
                options.outputFileName.standalone = path.join(startFile.cwd, options.outputFileName.standalone);
            }
            if (options.outputFileName.universal) {
                options.outputFileName.universal = path.join(startFile.cwd, options.outputFileName.universal);
            }
        }
        var p = new project.Project(startFile.path, usedIO, options);
        p.on('error', function (err) {
            error(err);
        });
        p.on('written', function () {
            stream.push(null);
        });
        p.start();
    };
    var fileNames = [];
    streamIO.on('addFile', function (err, file) {
        if (file.isNull())
            return;
        if (file.isStream()) {
            _this.emit('error', new Error('Streaming is not supported'));
        }
        fileNames.push(file.relative);
        if (io_1.pathsEqual(file.relative, startFileName)) {
            gulpCompile(file);
        }
    });
    streamIO.on('end', function () {
        if (!started) {
            error(new Error('The start file was not found. Choose one of: ' + fileNames.join(', ')));
        }
    });
    return stream;
}
exports.gulp = gulp;
